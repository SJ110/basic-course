操作系统：进程机进程管理

1.引入进程的原因：由于程序的并发执行，导致程序失去封闭性和可在现性（当存在共享变量时，程序的结果也许会不是我们预期的结果，及一个程序的执行会影响另一个程序的执行）。上述存在共享变量导致程序的执行结果不再预期内也称为与时间有关的错误。

2.进程的定义:进程是在给定活动空间和初始环境下，再一个处理及上的执行过程。（进程的定义很多：可以简单理解为进程时程序的一部分）。但是进程是动态概念，存在执行-等待-执行的规律。程序是静态的概念，进程是一个独立运行的基本单位，进程是竞争系统资源的基本单位。一条程序可以至多包含一条以上的进程。

3.进程的状态   等待态 就绪态 运行态  （创建态， 消亡态）
等待态：进程等待某一事件的发生而暂停执行，此时即使有cpu控制权也无法执行。

就绪态：进程包含了除cpu外的一切必须资源，此时有cpu控制权可以立即执行。

运行态：进程以获得运行所必须的资源，程序正在运行。

状态变迁： ![](https://blog.csdn.net/maliao1123/article/details/54973884)
注意：进程不能从等待态直接变为运行态，需要变到就绪态，才能在进程调度时转为运行态。各个状态的相互转化可以百度查看。

4.为了描述进程引入进程控制块（pcb）--描述进程的数据结构。进程控制块中存放了进程的相关信息：比如进程标识符（区别各个进程），进程的状态等。其中队列指针存放当前状态下的pcb地址，如果当前是就绪态，则该pcb存放在就绪队列中。

5.进程控制：为了对所有进程进行有效管理引入进程管理。（1.原语是一种特殊的系统调用，可以完成一个特定的功能，在执行时不可再分，具有原子性。

（2.进程控制原语包括：创建原语，撤消原语，阻塞原语，唤醒原语

创建原语：创建一个就具有指顶标识符的进程，同时创建进程的pcb结构。创建的子进程会继承父进程的属性，因此除了其标识符不同外，其他属性都相同。创建时会向系统请求一块pcb，如果系统中有多余pcb则会创建成功。（fork（））

撤销原语：（kill（））当进程结束后希望重指自己时使用撤销原语，撤销当前的进程，将该进程的pcb结构归还pcb资源池，所占用的资源归还父进程，从总链队列中摘除。

阻塞（等待）原语：当进程需要等待某一事件完成时可以调用阻塞原语将自己暂时挂起，一旦被挂起，只能等待另一个进程唤醒。 susp（chan） chan是进程等待的原因。

唤醒原语：当处于等待状态的进程所期待的事件到来时，就会唤醒该进程（susp（chan）） chan：进程等待的原因。

6.进程间的相互约束关系：进程间存在互斥和同步的关系，比如两个进程共享一台打印机就是互斥的例子，而对于一次打印过程，则需要缓冲区准备好时，才能进行打印，着称为同步。

互斥：在操作系统中，当某一个进程正在访问某一存储区域时，就不允许其他进程来读出或修改该存储区域的内容。

7.进程的同步采用pv操作进行，pv操作是不可分割的原语。
p(s)操作：s减一，若结果大于0，则继续执行进程。如果结果小于0，进程被挂起，并将他插入信号灯的等待队列中，然后转进程调度程序。

v(s)操作:s加1，若s大于0，则继续执行进程，如果结果小于0，则从信号等队列中移出一个进程，并解除他的等待状态，转为就绪态，返回进程继续执行。

7.进程互斥和同步的实现:

（1.进程互斥的实现：当存在临界区（共享变量）时，保证程序正确执行，使用互斥信号灯。


    `main()`
    `int mutex=1;`
    `cobegin  pa(); pb();`
    `coend`
    `pa(){`
    `p(mmutex);访问缓冲区;v(mutex);}`
    `pb(){ p(mutex);访问缓冲区；v(mutex);}
mutex=1；若先执行到pa，则mutex=0；访问缓冲区，此时在执行pa会使mutex=-1；导致pa暂时挂起,等待mutex=0时继续执行，当执行完pa后 mutex=0；此时可以继续执行pb。

进程同步的实现：（1.合作进程的执行次序 

（2.共享缓冲区的合作进程的同步：一下处理一个共享缓冲区的打印问题：

    `main()`
    `int s1=0;//buf中有无信息`
    `int s2=1;//buf有无空位置`
    `conbegin  cp(); iop();`
    `coend;`
    `cp(){`
    `while(计算未完成){`
    `计算得到数据；`
    `p(s2);数据放到buf；v(s1); //上锁}}`
    `iop(){`
    `while(打印未完成){`
    `p(s1);取出buf中数据；v(s2);}}`

生产者和消费者问题：这类问题是对同步问题的抽象描述。在这一类问题中，信号灯有两个功能，1.跟踪资源的计数器，2.协调生产者和消费者之间的同步器。消费者在一个表示满缓冲区的地方通过p操作消耗一块资源，生产者通过v操作生产一块资源。当资源不可用时，进程处在等待队列等待，当产生一块可用资源时，队列首部的第一个进程可以得到资源控制权。
下面以共享缓冲区打印的问题为例：

    `main(){`
    `int full=0;int empty=n;int mutex=1;//full，满缓冲区数目，empty：空缓冲区数， mutex：互斥信号灯。`
    `cobegin: p1();p2()...pn();`
    `c1();c2();...cn();`
    `coend;`
    `p1(){`
    `while(生产未完成){`
    `生产一个产品；p(empty);p(mutex);`
    `产品放入缓冲区;v(mutex);v(full);//满缓冲区数少1}}`
    `c1(){`
    `while（消费未完成）{`
    ` p(full);p(mutex);`
    `将产品从缓冲区取出;v(mutex);v(empty);消费一个产品；//空缓冲区数加1}}`

进程通信:指进程间以较高的效率传递较多数据的交互方式。方式包括消息缓冲通信（TCP/UDP协议?)和信箱通信。信箱通信的信箱可以放在用户空间也可以放在操作系统空间。值得注意的是在进行进程通信时需要注意进程的同步，如果信箱或者缓冲区没有信息则接收方需要等待，相反如果其中的数据没有接受的话，则发送方需要等待。

线程的概念及特点:线程包括五个状态：等待态 就绪态 运行态 创建态， 消亡态。 可以这样理解：进程是程序的一次执行过程，而线程是进程在这次执行过程中的一部分，

线程的描述：线程是进程的一条执行路径，拥有自己的堆栈段和处理执行环境。和父进程共享主存(包括共享父进程的程序i洗脑洗和全局数据)。每一个进程至少含有一条线程。其五个状态可以照进程的三个状态理解。

进程调度：功能1.记录进程的有关情况，2.决定调度策略3.实施处理及的分配和回收

调度方式:可剥夺方式：当重要紧迫的进程到来时，先让正在执行的进程等待，区执行优先级更高的进程， 不可剥夺方式：直到当前进程执行或者发生某事件进入等待之后在执行到来的进程。


进程调度算法：1.进程优先数调度算法：先执行优先数搞得进程，（优先数有静态优先数和动态优先数）2.循环轮转调度算法（当正在运行的进程执行完之后放入就绪队列的尾部等待下次执行）